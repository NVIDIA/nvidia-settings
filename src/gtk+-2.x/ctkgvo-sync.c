/*
 * nvidia-settings: A tool for configuring the NVIDIA X driver on Unix
 * and Linux systems.
 *
 * Copyright (C) 2004 NVIDIA Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses>.
 */

#include <gtk/gtk.h>
#include <NvCtrlAttributes.h>

#include <string.h>
#include <libintl.h>

#include "ctkbanner.h"

#include "ctkgvo.h"
#include "ctkgvo-sync.h"

#include "ctkconfig.h"
#include "ctkhelp.h"
#include "ctkutils.h"

#include "ctkdropdownmenu.h"

#define _(STRING) gettext(STRING)
#define N_(STRING) STRING

/*
 * The CtkGvoSync widget is used to provide a way for configuring
 * how the SDI device synchronises with an input signal source.
 */

#define FRAME_BORDER 5
#define TABLE_PADDING 5


#define DEFAULT_DETECT_INPUT_TIME_INTERVAL 2000


#define SYNC_FORMAT_SDI 0
#define SYNC_FORMAT_COMP_AUTO 1
#define SYNC_FORMAT_COMP_BI_LEVEL 2
#define SYNC_FORMAT_COMP_TRI_LEVEL 3

static const GvioFormatName syncFormatNames[] = {
    { SYNC_FORMAT_SDI,            "SDI Sync" },
    { SYNC_FORMAT_COMP_AUTO,      "COMP Sync" },
    { SYNC_FORMAT_COMP_BI_LEVEL,  "COMP Sync (Bi-level)" },
    { SYNC_FORMAT_COMP_TRI_LEVEL, "COMP Sync (Tri-level)" },
    { -1, NULL },
};

extern const GvioFormatName videoFormatNames[];



/* local prototypes */

static GtkWidget *start_menu(const gchar *name, GtkWidget *table,
                             const gint row);
static void finish_menu(GtkWidget *menu, GtkWidget *table, const gint row);


static gboolean query_init_gvo_sync_state(CtkGvoSync *ctk_gvo_sync);
static void init_composite_termination(CtkGvoSync *ctk_gvo_sync);
static void init_sync_format_menu(CtkGvoSync *ctk_gvo_sync);
static void register_for_gvo_sync_events(CtkGvoSync *ctk_gvo_sync);


static void update_gvo_sync_sensitivity(CtkGvoSync *ctk_gvo_sync);
static void update_input_video_format_text_entry(CtkGvoSync *ctk_gvo_sync);
static void post_composite_termination_toggled(CtkGvoSync *ctk_gvo_sync,
                                               gboolean enabled);


static void detect_input_toggled(GtkToggleButton *togglebutton,
                                 CtkGvoSync *ctk_gvo_sync);
static gint detect_input_done(gpointer data);
static void composite_termination_toggled(GtkWidget *button,
                                          CtkGvoSync *ctk_gvo_sync);
static void sync_mode_changed(CtkDropDownMenu *menu, gpointer user_data);
static void sync_format_changed(CtkDropDownMenu *menu, gpointer user_data);
static void hsync_delay_changed(GtkSpinButton *spinbutton, gpointer user_data);
static void vsync_delay_changed(GtkSpinButton *spinbutton, gpointer user_data);


static void gvo_sync_event_received(GObject *object, CtrlEvent *event,
                                    gpointer user_data);
static gint gvo_sync_probe_callback(gpointer data);



/* Help tooltips */

static const char * __input_video_format_help =
N_("The Input Video Format text entry indicates the input video format detected "
"on the input BNC.");

static const char * __input_video_format_detect_help =
N_("The Input Video Format Detect button will (re)detect the video format on "
"the input BNC.");

static const char * __composite_termination_help =
N_("The Enable Composite Termination checkbox enables the 75 ohm termination "
"of the composite input signal");

static const char * __sync_mode_help =
N_("The Sync Mode dropdown allows you to select how the SDI device syncs its "
"output to the input signal.");

static const char * __sync_format_help =
N_("The Sync Format dropdown allows you to select the format of the input sync "
"signal.");

static const char * __sync_status_help =
N_("The Sync Status reports on how the SDI device is currently syncing to the "
"input sync signal.");

static const char * __hsync_delay_help =
N_("The HSync Delay entry allows you to specify the horizontal delay between the "
"input signal and the output signal generated by the SDI device.");

static const char * __hsync_advance_help =
N_("The HSync Advance entry allows you to specify the horizontal advance between "
"the input signal and the output signal generated by the SDI device.");

static const char * __vsync_delay_help =
N_("The VSync Delay entry allows you to specify the vertical delay between the "
"input signal and the output signal generated by the SDI device.");

static const char * __vsync_advance_help =
N_("The VSync Advance entry allows you to specify the vertical advance between "
"the input signal and the output signal generated by the SDI device.");




/**** Utility Functions ******************************************************/

/*
 * ctk_gvo_sync_get_type() - Returns the CtkGvoSync "class" type
 */

GType ctk_gvo_sync_get_type(void)
{
    static GType ctk_gvo_sync_type = 0;
    
    if (!ctk_gvo_sync_type) {
        static const GTypeInfo ctk_gvo_sync_info = {
            sizeof (CtkGvoSyncClass),
            NULL, /* base_init */
            NULL, /* base_finalize */
            NULL, /* class_init, */
            NULL, /* class_finalize */
            NULL, /* class_data */
            sizeof (CtkGvoSync),
            0, /* n_preallocs */
            NULL, /* instance_init */
            NULL  /* value_table */
        };

        ctk_gvo_sync_type =
            g_type_register_static (GTK_TYPE_VBOX,
                                    "CtkGvoSync", &ctk_gvo_sync_info, 0);
    }
    
    return ctk_gvo_sync_type;

} /* ctk_gvo_sync_get_type() */



/*
 * max_input_video_format_text_entry_length()
 */

static int max_input_video_format_text_entry_length(void)
{
    gint i, tmp, max = 0;

    for (i = 0; videoFormatNames[i].name; i++) {
        tmp = strlen(videoFormatNames[i].name);
        if (max < tmp) max = tmp;
    }

    return max;

} /* max_input_video_format_text_entry_length() */



/*
 * get_current_sync_format() - given the current state of the
 * sync source and composite detection mode, return the value
 * to use for the sync format dropdown.
 */

static gint get_current_sync_format(CtkGvoSync *ctk_gvo_sync)
{
    /* Setup the sync format menu */

    if (ctk_gvo_sync->sync_source == NV_CTRL_GVO_SYNC_SOURCE_SDI) {
        return SYNC_FORMAT_SDI;
    } else if (ctk_gvo_sync->comp_mode ==
               NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_AUTO) {
        return SYNC_FORMAT_COMP_AUTO;
    } else if (ctk_gvo_sync->comp_mode ==
               NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_BI_LEVEL) {
        return SYNC_FORMAT_COMP_BI_LEVEL;
    } else if (ctk_gvo_sync->comp_mode ==
               NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_TRI_LEVEL){
        return SYNC_FORMAT_COMP_TRI_LEVEL;
    }

    // should not get here
    return SYNC_FORMAT_SDI;

} /* get_current_sync_format() */



/*
 * sync_signal_detected() - Returns whether or not a sync signal
 * is currently detected.
 */

static gboolean sync_signal_detected(CtkGvoSync *ctk_gvo_sync)
{
    /* Is a sync signal detected? */
    
    if ((ctk_gvo_sync->comp_sync_input_detected !=
         NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECTED_FALSE) ||
        (ctk_gvo_sync->sdi_sync_input_detected !=
         NV_CTRL_GVO_SDI_SYNC_INPUT_DETECTED_NONE)) {

        return TRUE;
    }

    return FALSE;
}



/*
 * set_sync_format_menu() - Selects the sync format drop down menu
 * entry based on the current sync source and composite detection mode.
 */

static void set_sync_format_menu(CtkGvoSync *ctk_gvo_sync)
{
    gint val = get_current_sync_format(ctk_gvo_sync);
    
    ctk_drop_down_menu_set_current_value
        (CTK_DROP_DOWN_MENU(ctk_gvo_sync->sync_format_menu), val);
}



/*
 * update_sync_lock_status_text() - Sets the correct text based on the
 * current state of input sync lock.
 */

static void update_sync_lock_status_text(CtkGvoSync *ctk_gvo_sync)
{
    gchar *str = _("Free Running");

    switch (ctk_gvo_sync->sync_mode) {

    case NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING:
        gtk_widget_set_sensitive(ctk_gvo_sync->sync_lock_status_text, FALSE);
        break;

    case NV_CTRL_GVO_SYNC_MODE_GENLOCK:
        gtk_widget_set_sensitive(ctk_gvo_sync->sync_lock_status_text, TRUE);
        if (ctk_gvo_sync->sync_lock_status ==
            NV_CTRL_GVO_SYNC_LOCK_STATUS_LOCKED) {
            str = _("GenLocked");
        }
        break;

    case NV_CTRL_GVO_SYNC_MODE_FRAMELOCK:
        gtk_widget_set_sensitive(ctk_gvo_sync->sync_lock_status_text, TRUE);
        if (ctk_gvo_sync->sync_lock_status ==
            NV_CTRL_GVO_SYNC_LOCK_STATUS_LOCKED) {
            str = _("FrameLocked");
        }        break;

    default:
        gtk_widget_set_sensitive(ctk_gvo_sync->sync_lock_status_text, FALSE);
        str = _("Unknown");
        break;
    }

    gtk_label_set_text(GTK_LABEL(ctk_gvo_sync->sync_lock_status_text), str);

} /* update_sync_lock_status_text() */




/**** Creation Functions *****************************************************/

/*
 * ctk_gvo_sync_new() - create a CtkGvoSync widget
 */

GtkWidget* ctk_gvo_sync_new(CtrlTarget *ctrl_target,
                            GtkWidget *parent_window,
                            CtkConfig *ctk_config,
                            CtkEvent *ctk_event,
                            CtkGvo *gvo_parent)
{
    GObject *object;
    CtkGvoSync *ctk_gvo_sync;
    GtkWidget *frame;
    GtkWidget *hbox;
    GtkWidget *label;
    GtkWidget *alignment;
    GtkWidget *button;

    GtkWidget *table, *menu;

    gint val, i;
    CtrlAttributeValidValues valid;
    ReturnStatus ret;
    gint row;

    const char *help_text;

    /* make sure we have a valid target */

    g_return_val_if_fail((ctrl_target != NULL) &&
                         (ctrl_target->h != NULL), NULL);

    /* create and initialize the object */

    object = g_object_new(CTK_TYPE_GVO_SYNC, NULL);

    ctk_gvo_sync = CTK_GVO_SYNC(object);
    ctk_gvo_sync->ctrl_target = ctrl_target;
    ctk_gvo_sync->parent_window = parent_window;
    ctk_gvo_sync->ctk_config = ctk_config;
    ctk_gvo_sync->ctk_event = ctk_event;
    ctk_gvo_sync->gvo_parent = gvo_parent;

    /* Query the current GVO state */

    if ( !query_init_gvo_sync_state(ctk_gvo_sync) ) {
        // Free the object
        g_object_ref(object);
        ctk_g_object_ref_sink(G_OBJECT(object));
        g_object_unref(object);
        return NULL;
    }

    /* set container properties for the widget */

    gtk_box_set_spacing(GTK_BOX(object), 10);
    
    /* banner */
    
    hbox = gtk_hbox_new(FALSE, 0);
    gtk_box_pack_start(GTK_BOX(object), hbox, FALSE, FALSE, 0);

    ctk_gvo_sync->banner_box = hbox;

    /*
     * Sync options
     */
    
    frame = gtk_frame_new(_("Sync Options"));
    ctk_gvo_sync->frame = frame;
    
    gtk_box_pack_start(GTK_BOX(object), frame, FALSE, FALSE, 0);
    
    table = gtk_table_new(6, 2, FALSE);
    gtk_table_set_row_spacings(GTK_TABLE(table), 0);
    gtk_table_set_col_spacings(GTK_TABLE(table), 0);

    gtk_container_add(GTK_CONTAINER(frame), table);

    /* input video format */

    label = gtk_label_new(_("Input Video Format: "));
    gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
    gtk_table_attach(GTK_TABLE(table), label,
                     0, 1,  0, 1, GTK_FILL, GTK_FILL,
                     TABLE_PADDING, TABLE_PADDING);

    hbox = gtk_hbox_new(FALSE, 5);

    ctk_gvo_sync->input_video_format_text_entry = gtk_entry_new();

    ctk_config_set_tooltip(ctk_config,
                           ctk_gvo_sync->input_video_format_text_entry,
                           _(__input_video_format_help));
    
    gtk_entry_set_width_chars
        (GTK_ENTRY(ctk_gvo_sync->input_video_format_text_entry),
         max_input_video_format_text_entry_length());

    gtk_widget_set_sensitive(ctk_gvo_sync->input_video_format_text_entry,
                             FALSE);

    update_input_video_format_text_entry(ctk_gvo_sync);

    gtk_box_pack_start(GTK_BOX(hbox),
                       ctk_gvo_sync->input_video_format_text_entry,
                       TRUE, TRUE, 0);

    /* Input video format detect button */

    button = gtk_toggle_button_new_with_label(_("Detect"));
    alignment = gtk_alignment_new(1, 1, 0, 0);
    gtk_container_add(GTK_CONTAINER(alignment), button);

    ctk_gvo_sync->input_video_format_detect_button = button;

    ctk_config_set_tooltip(ctk_config, button,
                           _(__input_video_format_detect_help));
    
    g_signal_connect(G_OBJECT(button), "toggled",
                     G_CALLBACK(detect_input_toggled), ctk_gvo_sync);

    gtk_box_pack_start(GTK_BOX(hbox), alignment, FALSE, FALSE, 0);

    gtk_table_attach(GTK_TABLE(table), hbox,
                     1, 2, 0, 1, GTK_FILL | GTK_EXPAND, GTK_FILL,
                     TABLE_PADDING, TABLE_PADDING);

    /* Composite Termination */

    if (ctk_gvo_sync->caps & NV_CTRL_GVO_CAPABILITIES_COMPOSITE_TERMINATION) {

        button =
            gtk_check_button_new_with_label(_("Enable Composite Termination"));
        
        ctk_config_set_tooltip(ctk_config, button,
                               _(__composite_termination_help));

        alignment = gtk_alignment_new(1, 1, 0, 0);
        
        gtk_container_add(GTK_CONTAINER(alignment), button);
        gtk_table_attach(GTK_TABLE(table), alignment,
                         0, 2, 2, 3, GTK_FILL | GTK_EXPAND, GTK_FILL,
                         TABLE_PADDING, TABLE_PADDING);
        
        ctk_gvo_sync->composite_termination_button = button;
        
        init_composite_termination(ctk_gvo_sync);
        
        g_signal_connect(G_OBJECT(button), "toggled",
                         G_CALLBACK(composite_termination_toggled),
                         ctk_gvo_sync);

        row = 3;
    } else {
        ctk_gvo_sync->composite_termination_button = NULL;
        row = 2;
    }

    /* Sync Mode */

    menu = start_menu(_("Sync Mode: "), table, row);
    
    ctk_drop_down_menu_append_item(CTK_DROP_DOWN_MENU(menu), _("Free Running"),
                                   NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING);
    
    ctk_drop_down_menu_append_item(CTK_DROP_DOWN_MENU(menu), _("GenLock"),
                                   NV_CTRL_GVO_SYNC_MODE_GENLOCK);
    
    ctk_drop_down_menu_append_item(CTK_DROP_DOWN_MENU(menu), _("FrameLock"),
                                   NV_CTRL_GVO_SYNC_MODE_FRAMELOCK);
    
    finish_menu(menu, table, row);
    row++;
    
    ctk_gvo_sync->sync_mode_menu = menu;

    ctk_drop_down_menu_set_tooltip(ctk_config, CTK_DROP_DOWN_MENU(menu),
                                   _(__sync_mode_help));

    ctk_drop_down_menu_set_current_value
        (CTK_DROP_DOWN_MENU(ctk_gvo_sync->sync_mode_menu),
         ctk_gvo_sync->sync_mode);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->sync_mode_menu), "changed",
                     G_CALLBACK(sync_mode_changed), (gpointer) ctk_gvo_sync);

    /* Sync Format */

    menu = start_menu(_("Sync Format: "), table, row);
    
    for (i = 0; syncFormatNames[i].name; i++) {
        ctk_drop_down_menu_append_item(CTK_DROP_DOWN_MENU(menu),
                                       syncFormatNames[i].name,
                                       syncFormatNames[i].format);
    }
    
    finish_menu(menu, table, row);
    row++;

    ctk_gvo_sync->sync_format_menu = menu;

    ctk_drop_down_menu_set_tooltip(ctk_config, CTK_DROP_DOWN_MENU(menu),
                                   _(__sync_format_help));

    init_sync_format_menu(ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->sync_format_menu),
                     "changed", G_CALLBACK(sync_format_changed),
                     (gpointer) ctk_gvo_sync);

    /* Sync Status */

    label = gtk_label_new(_("Sync Status:"));
    gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
    gtk_table_attach(GTK_TABLE(table), label, 0, 1, row, row+1,
                     GTK_FILL, GTK_FILL, TABLE_PADDING, TABLE_PADDING);

    ctk_gvo_sync->sync_lock_status_text = gtk_label_new("");

    update_sync_lock_status_text(ctk_gvo_sync);

    hbox = gtk_hbox_new(FALSE, 5);
    gtk_box_pack_start(GTK_BOX(hbox), ctk_gvo_sync->sync_lock_status_text,
                       FALSE, FALSE, 0);

    gtk_table_attach(GTK_TABLE(table), hbox,
                     1, 2, row, row+1,
                     GTK_FILL /*| GTK_EXPAND*/, GTK_FILL,
                     TABLE_PADDING, TABLE_PADDING);
    row++;


    /*
     * Synchronization Skew (Delay/Advance)
     */

    /* NV_CTRL_GVO_SYNC_DELAY_PIXELS */

    ret = NvCtrlGetValidAttributeValues(ctrl_target,
                                        NV_CTRL_GVO_SYNC_DELAY_PIXELS,
                                        &valid);

    if ((ret == NvCtrlSuccess) &&
        (valid.valid_type == CTRL_ATTRIBUTE_VALID_TYPE_RANGE)) {

        ret = NvCtrlGetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_DELAY_PIXELS,
                                 &val);
        if (ret != NvCtrlSuccess) val = 0;

        if (ctk_gvo_sync->caps & NV_CTRL_GVO_CAPABILITIES_ADVANCE_SYNC_SKEW) {
            label = gtk_label_new(_("HSync Advance:"));
            help_text = _(__hsync_advance_help);
        } else {
            label = gtk_label_new(_("HSync Delay:"));
            help_text = _(__hsync_delay_help);
        }

        gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
        gtk_table_attach(GTK_TABLE(table), label, 0, 1, row, row+1,
                         GTK_FILL, GTK_FILL, TABLE_PADDING, TABLE_PADDING);

        ctk_gvo_sync->hsync_delay_spin_button =
            gtk_spin_button_new_with_range(valid.range.min,
                                           valid.range.max, 1);

        ctk_config_set_tooltip(ctk_config,
                               ctk_gvo_sync->hsync_delay_spin_button,
                               help_text);

        gtk_spin_button_set_value
            (GTK_SPIN_BUTTON(ctk_gvo_sync->hsync_delay_spin_button), val);
    
        g_signal_connect(G_OBJECT(ctk_gvo_sync->hsync_delay_spin_button),
                         "value-changed",
                         G_CALLBACK(hsync_delay_changed), ctk_gvo_sync);

        hbox = gtk_hbox_new(FALSE, 5);
        gtk_box_pack_start(GTK_BOX(hbox),
                           ctk_gvo_sync->hsync_delay_spin_button,
                           FALSE, FALSE, 0);

        label = gtk_label_new("(pixels)");
        gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
        gtk_box_pack_start(GTK_BOX(hbox), label,
                           FALSE, FALSE, 0);

        gtk_table_attach(GTK_TABLE(table), hbox,
                         1, 2, row, row+1,
                         GTK_FILL /*| GTK_EXPAND*/, GTK_FILL,
                         TABLE_PADDING, TABLE_PADDING);
        row++;
    }

    /* NV_CTRL_GVO_SYNC_DELAY_LINES */

    ret = NvCtrlGetValidAttributeValues(ctrl_target,
                                        NV_CTRL_GVO_SYNC_DELAY_LINES,
                                        &valid);

    if ((ret == NvCtrlSuccess) &&
        (valid.valid_type == CTRL_ATTRIBUTE_VALID_TYPE_RANGE)) {

        ret = NvCtrlGetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_DELAY_LINES,
                                 &val);
        if (ret != NvCtrlSuccess) val = 0;

        if (ctk_gvo_sync->caps & NV_CTRL_GVO_CAPABILITIES_ADVANCE_SYNC_SKEW) {
            label = gtk_label_new(_("VSync Advance:"));
            help_text = _(__vsync_advance_help);
        } else {
            label = gtk_label_new(_("VSync Delay:"));
            help_text = _(__vsync_delay_help);
        }

        gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
        gtk_table_attach(GTK_TABLE(table), label, 0, 1, row, row+1,
                         GTK_FILL, GTK_FILL, TABLE_PADDING, TABLE_PADDING);

        ctk_gvo_sync->vsync_delay_spin_button =
            gtk_spin_button_new_with_range(valid.range.min,
                                           valid.range.max, 1);

        ctk_config_set_tooltip(ctk_config,
                               ctk_gvo_sync->vsync_delay_spin_button,
                               help_text);

        gtk_spin_button_set_value
            (GTK_SPIN_BUTTON(ctk_gvo_sync->vsync_delay_spin_button), val);
        
        g_signal_connect(G_OBJECT(ctk_gvo_sync->vsync_delay_spin_button),
                         "value-changed",
                         G_CALLBACK(vsync_delay_changed), ctk_gvo_sync);

        hbox = gtk_hbox_new(FALSE, 5);
        gtk_box_pack_start(GTK_BOX(hbox),
                           ctk_gvo_sync->vsync_delay_spin_button,
                           FALSE, FALSE, 0);

        label = gtk_label_new("(lines)");
        gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
        gtk_box_pack_start(GTK_BOX(hbox), label,
                           FALSE, FALSE, 0);

        gtk_table_attach(GTK_TABLE(table), hbox,
                         1, 2, row, row+1,
                         GTK_FILL /*| GTK_EXPAND*/, GTK_FILL,
                         TABLE_PADDING, TABLE_PADDING);
        row++;
    }

    /* create the watch cursor (for use when the "Detect" button is toggled" */
    
    ctk_gvo_sync->wait_cursor = gdk_cursor_new(GDK_WATCH);

    /* Set UI sensitivity */

    update_gvo_sync_sensitivity(ctk_gvo_sync);

    /* Start listening for events */

    register_for_gvo_sync_events(ctk_gvo_sync);

    /* show the page */

    gtk_widget_show_all(GTK_WIDGET(object));

    return GTK_WIDGET(object);

} /* ctk_gvo_sync_new() */



/*
 * start_menu() - Start the creation of a labeled dropdown menu.  (Packs
 * the dropdown label into the table row.
 */

static GtkWidget *start_menu(const gchar *name, GtkWidget *table,
                             const gint row)
{
    GtkWidget *menu, *label, *alignment;
    
    label = gtk_label_new(name);
    alignment = gtk_alignment_new(0, 0, 0, 0);
    gtk_container_add(GTK_CONTAINER(alignment), label);

    gtk_table_attach(GTK_TABLE(table),
                     alignment, 0, 1, row, row+1, GTK_FILL, GTK_FILL,
                     TABLE_PADDING, TABLE_PADDING);
    
    menu = ctk_drop_down_menu_new(CTK_DROP_DOWN_MENU_FLAG_READONLY);
    
    return menu;
}



/*
 * finish_menu() - Finish/Finalize a dropdown menu. (Packs the menu in
 * the table row.)
 */

static void finish_menu(GtkWidget *menu, GtkWidget *table, const gint row)
{
    gtk_widget_show_all(menu);

    gtk_table_attach(GTK_TABLE(table), menu, 1, 2, row, row+1,
                     GTK_FILL | GTK_EXPAND, GTK_FILL,
                     TABLE_PADDING, TABLE_PADDING);
}




/**** Initialization Functions ***********************************************/

/*
 * query_init_gvo_sync_state() - Query the initial GVO state so we can setup
 * the UI correctly.
 */

static gboolean query_init_gvo_sync_state(CtkGvoSync *ctk_gvo_sync)
{
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gint val;
    ReturnStatus ret;


    /* Check if this screen supports GVO */

    ret = NvCtrlGetAttribute(ctrl_target, NV_CTRL_GVO_SUPPORTED,
                             &val);
    if ((ret != NvCtrlSuccess) || (val != NV_CTRL_GVO_SUPPORTED_TRUE)) {
        /* GVO not available */
        return FALSE;
    }

    /* Get this GVO device's capabilities */

    ret = NvCtrlGetAttribute(ctrl_target, NV_CTRL_GVO_CAPABILITIES,
                             &val);
    if (ret != NvCtrlSuccess) return FALSE;
    ctk_gvo_sync->caps = val;

    /* Query the current input video formats */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVIO_DETECTED_VIDEO_FORMAT, &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVIO_VIDEO_FORMAT_NONE;
    }
    ctk_gvo_sync->input_video_format = val;

    /* Query the sync mode */

    ret = NvCtrlGetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_MODE,
                             &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING;
    }
    ctk_gvo_sync->sync_mode = val;

    /* query COMPOSITE_SYNC_INPUT_DETECTED */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECTED, &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECTED_FALSE;
    }
    ctk_gvo_sync->comp_sync_input_detected = val;

    /* query COMPOSITE_SYNC_INPUT_DETECT_MODE */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE,
                             &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_AUTO;
    }
    ctk_gvo_sync->comp_mode = val;

    /* query SDI_SYNC_INPUT_DETECTED */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_SDI_SYNC_INPUT_DETECTED, &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_SDI_SYNC_INPUT_DETECTED_NONE;
    }
    ctk_gvo_sync->sdi_sync_input_detected = val;

    /* query sync source */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_SYNC_SOURCE,
                             &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_SYNC_SOURCE_SDI;
    }
    ctk_gvo_sync->sync_source = val;

    /* Query framelock/genlock status */

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_SYNC_LOCK_STATUS,
                             &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_SYNC_LOCK_STATUS_UNLOCKED;
    }
    ctk_gvo_sync->sync_lock_status = val;

    return TRUE;

} /* query_init_gvo_sync_state() */



/*
 * init_composite_termination() - Initialize the state of the composite
 * termination button.
 */

static void init_composite_termination(CtkGvoSync *ctk_gvo_sync)
{
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    ReturnStatus ret;
    gint val;

    if (!ctk_gvo_sync->composite_termination_button) return;

    ret = NvCtrlGetAttribute(ctrl_target,
                             NV_CTRL_GVO_COMPOSITE_TERMINATION, &val);
    if (ret != NvCtrlSuccess) {
        val = NV_CTRL_GVO_COMPOSITE_TERMINATION_DISABLE;
    }

    gtk_toggle_button_set_active
        (GTK_TOGGLE_BUTTON(ctk_gvo_sync->composite_termination_button),
         val == NV_CTRL_GVO_COMPOSITE_TERMINATION_ENABLE);

} /* init_composite_termination() */



/*
 * init_sync_format_menu() - initialize the sync format menu
 */

static void init_sync_format_menu(CtkGvoSync *ctk_gvo_sync)
{
    set_sync_format_menu(ctk_gvo_sync);

} /* init_sync_format_menu() */



/*
 * register_for_gvo_sync_events() - Configure ctk_gvo_sync object to listen
 * for GVO synchronization related evens.
 */

static void register_for_gvo_sync_events(CtkGvoSync *ctk_gvo_sync)
{
    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_SYNC_MODE),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_SYNC_SOURCE),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_SYNC_DELAY_PIXELS),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_SYNC_DELAY_LINES),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

    g_signal_connect(G_OBJECT(ctk_gvo_sync->ctk_event),
                     CTK_EVENT_NAME(NV_CTRL_GVO_COMPOSITE_TERMINATION),
                     G_CALLBACK(gvo_sync_event_received),
                     (gpointer) ctk_gvo_sync);

} /* register_for_gvo_sync_events() */




/**** Common Update Functions ************************************************/

/*
 * update_gvo_sync_sensitivity() - Updates the sensitivity of various UI
 * widgets based on whether or not an input sync signal is detected.
 *
 */

static void update_gvo_sync_sensitivity(CtkGvoSync *ctk_gvo_sync)
{
    gboolean sensitive;

    /* Allow selection of the sync format if we're not free-running */

    sensitive = (ctk_gvo_sync->sync_mode != NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING);

    gtk_widget_set_sensitive(ctk_gvo_sync->sync_format_menu, sensitive);

    /* Update options that require a valid sync signal */

    sensitive = (sensitive && sync_signal_detected(ctk_gvo_sync));

    if (ctk_gvo_sync->hsync_delay_spin_button) {
        gtk_widget_set_sensitive(ctk_gvo_sync->hsync_delay_spin_button,
                                 sensitive);
    }
    if (ctk_gvo_sync->vsync_delay_spin_button) {
        gtk_widget_set_sensitive(ctk_gvo_sync->vsync_delay_spin_button,
                                 sensitive);
    }

} /* update_gvo_sync_sensitivity() */



/*
 * update_input_video_format_text_entry() - Displays the currently detected
 * input video format.
 */

static void update_input_video_format_text_entry(CtkGvoSync *ctk_gvo_sync)
{
    gint i;
    const gchar *str;
    
    if (ctk_gvo_sync->sync_mode == NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING) {
        str = _("Free Running");
    } else {
        str = _("No incoming signal detected");
        for (i = 0; videoFormatNames[i].name; i++) {
            if (videoFormatNames[i].format == ctk_gvo_sync->input_video_format) {
                str = videoFormatNames[i].name;
            }
        }
    }
    gtk_entry_set_text(GTK_ENTRY(ctk_gvo_sync->input_video_format_text_entry), str);
    
} /* update_input_video_format_text_entry() */



/*
 * post_composite_termination_toggled() - Call this function after
 * the composite termination attribute has changed.
 */

static void post_composite_termination_toggled(CtkGvoSync *ctk_gvo_sync,
                                               gboolean enabled)
{
    /* update the statusbar */
    
    ctk_config_statusbar_message(ctk_gvo_sync->ctk_config,
                                 enabled ? _("Composite Termination Enabled.") : _("Composite Termination Disabled."));

} /* post_composite_termination_toggled() */



/*
 * post_sync_mode_menu_changed() - Call this function after the sync mode
 * menu has changed.
 *
 */

static void post_sync_mode_menu_changed(CtkGvoSync *ctk_gvo_sync, gint value)
{
    char *name;

    /* Update the UI */

    update_input_video_format_text_entry(ctk_gvo_sync);
    update_gvo_sync_sensitivity(ctk_gvo_sync);
    
    switch (value) {
    case NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING: name = _("Free Running"); break;
    case NV_CTRL_GVO_SYNC_MODE_GENLOCK:      name = _("GenLock");      break;
    case NV_CTRL_GVO_SYNC_MODE_FRAMELOCK:    name = _("FrameLock");    break;
    default: return;
    }

    ctk_config_statusbar_message(ctk_gvo_sync->ctk_config,
                                 _("Sync Mode set to %s."), name);    

} /* post_sync_mode_menu_changed() */



/*
 * post_sync_format_menu_changed() - Call this function after the sync
 * format has changed.
 */

static void post_sync_format_menu_changed(CtkGvoSync *ctk_gvo_sync)
{
    const char *name = _("Unknown");
    gint value;
    gint i;

    
    /* Update the status bar */

    value = get_current_sync_format(ctk_gvo_sync);

    for (i = 0; syncFormatNames[i].name; i++) {
        if (syncFormatNames[i].format == value) {
            name = syncFormatNames[i].name;
            break;
        }
    }

    ctk_config_statusbar_message(ctk_gvo_sync->ctk_config,
                                 _("Sync Format set to \"%s\"."), name);

} /* post_sync_format_menu_changed() */




/**** UI Event Handlers ************************************************/

/*
 * detect_input_toggled() - if the Detect button is enabled, then enable
 * INPUT_VIDEO_FORMAT_REACQUIRE, make everything else insensitive,
 * switch to the wait cursor, and queue detect_input_done() to be
 * called.
 */

static void detect_input_toggled(GtkToggleButton *togglebutton,
                                 CtkGvoSync *ctk_gvo_sync)
{
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gboolean enabled;

    enabled = gtk_toggle_button_get_active(togglebutton);

    if (!enabled) return;
        
    /* grab the server */
    
    gtk_grab_add(ctk_gvo_sync->input_video_format_detect_button);

    /* change the cursor */

    gdk_window_set_cursor
        (ctk_widget_get_window(GTK_WIDGET(ctk_gvo_sync->parent_window)),
         ctk_gvo_sync->wait_cursor);
    
    /* make all other widgets insensitive */

    gtk_widget_set_sensitive(ctk_gvo_sync->frame, FALSE);
    
    /* enable REACQUIRE */

    NvCtrlSetAttribute(ctrl_target,
                       NV_CTRL_GVO_INPUT_VIDEO_FORMAT_REACQUIRE,
                       NV_CTRL_GVO_INPUT_VIDEO_FORMAT_REACQUIRE_TRUE);

    /* update the statusbar */

    ctk_config_statusbar_message(ctk_gvo_sync->ctk_config,
                                 _("Detecting incoming signal..."));
    
    /* register the "done" function */
    
    g_timeout_add(DEFAULT_DETECT_INPUT_TIME_INTERVAL,
                  detect_input_done, (gpointer) ctk_gvo_sync);
    
} /* detect_input_toggled() */



/*
 * detect_input_done() - done detecting; disable REACQUIRE, make all
 * widgets sensitive again, and probe the new state
 */

static gint detect_input_done(gpointer data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(data);
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;

    /* disable REACQUIRE */

    NvCtrlSetAttribute(ctrl_target,
                       NV_CTRL_GVO_INPUT_VIDEO_FORMAT_REACQUIRE,
                       NV_CTRL_GVO_INPUT_VIDEO_FORMAT_REACQUIRE_FALSE);

    /* reprobe */
    
    ctk_gvo_banner_probe((gpointer)(ctk_gvo_sync->gvo_parent->banner));
    
    /* un-press the detect button */
    
    g_signal_handlers_block_by_func
        (G_OBJECT(ctk_gvo_sync->input_video_format_detect_button),
         G_CALLBACK(detect_input_toggled),
         (gpointer) ctk_gvo_sync);
    
    gtk_toggle_button_set_active
        (GTK_TOGGLE_BUTTON(ctk_gvo_sync->input_video_format_detect_button), FALSE);

    g_signal_handlers_unblock_by_func
        (G_OBJECT(ctk_gvo_sync->input_video_format_detect_button),
         G_CALLBACK(detect_input_toggled),
         (gpointer) ctk_gvo_sync);
    
    /* update the status bar */
    
    ctk_config_statusbar_message(ctk_gvo_sync->ctk_config,
                                 _("Done detecting incoming signal."));
    
    /* restore sensitivity */
    
    gtk_widget_set_sensitive(ctk_gvo_sync->frame, TRUE);

    /* restore the cursor */

    gdk_window_set_cursor(ctk_widget_get_window(GTK_WIDGET(ctk_gvo_sync->parent_window)),
                          NULL);

    /* ungrab the server */
    
    gtk_grab_remove(ctk_gvo_sync->input_video_format_detect_button);
    
    return FALSE;

} /* detect_input_done() */



/*
 * composite_termination_toggled() - Called when the user clicks
 * on the "Enable Composite Termination" check button.
 */

static void composite_termination_toggled(GtkWidget *button,
                                          CtkGvoSync *ctk_gvo_sync)
{
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gboolean enabled;

    enabled = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button));

    NvCtrlSetAttribute(ctrl_target,
                       NV_CTRL_GVO_COMPOSITE_TERMINATION,
                       (enabled ? NV_CTRL_GVO_COMPOSITE_TERMINATION_ENABLE :
                        NV_CTRL_GVO_COMPOSITE_TERMINATION_DISABLE));

    post_composite_termination_toggled(ctk_gvo_sync, enabled);

} /* composite_termination_toggled() */



/*
 * sync_mode_changed() - callback when the user makes a selection from the
 * sync mode menu.
 */

static void sync_mode_changed(CtkDropDownMenu *menu, gpointer user_data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(user_data);
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gint value;

    value = ctk_drop_down_menu_get_current_value(menu);

    NvCtrlSetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_MODE, value);

    if (value != NV_CTRL_GVO_SYNC_MODE_FREE_RUNNING) {
        NvCtrlSetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_SOURCE,
                           ctk_gvo_sync->sync_source);
    }

    ctk_gvo_sync->sync_mode = value;

    post_sync_mode_menu_changed(ctk_gvo_sync, value);
    
} /* sync_mode_changed() */



/*
 * sync_format_changed() - callback when the user makes a selection from the
 * sync format menu (from the UI.)
 */

static void sync_format_changed(CtkDropDownMenu *menu, gpointer user_data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(user_data);
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gint value, sync_source, comp_mode;

    value = ctk_drop_down_menu_get_current_value(menu);

    switch (value) {
    case SYNC_FORMAT_SDI:
        sync_source = NV_CTRL_GVO_SYNC_SOURCE_SDI;
        comp_mode = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_AUTO;
        break;
    case SYNC_FORMAT_COMP_AUTO:
        sync_source = NV_CTRL_GVO_SYNC_SOURCE_COMPOSITE;
        comp_mode = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_AUTO;
        break;
    case SYNC_FORMAT_COMP_BI_LEVEL:
        sync_source = NV_CTRL_GVO_SYNC_SOURCE_COMPOSITE;
        comp_mode = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_BI_LEVEL;
        break;
    case SYNC_FORMAT_COMP_TRI_LEVEL:
        sync_source = NV_CTRL_GVO_SYNC_SOURCE_COMPOSITE;
        comp_mode = NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE_TRI_LEVEL;
        break;
    default:
        return;
    }

    ctk_gvo_sync->sync_source = sync_source;
    ctk_gvo_sync->comp_mode = comp_mode;

    NvCtrlSetAttribute(ctrl_target,
                       NV_CTRL_GVO_SYNC_SOURCE, sync_source);

    NvCtrlSetAttribute(ctrl_target,
                       NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE,
                       comp_mode);

    post_sync_format_menu_changed(ctk_gvo_sync);

} /* sync_format_changed() */



/*
 * hsync_delay_changed() - UI Callback function for when the user changes
 * the hsync delay.
 */

static void hsync_delay_changed(GtkSpinButton *spinbutton, gpointer user_data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(user_data);
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gint val;

    val = gtk_spin_button_get_value(spinbutton);

    NvCtrlSetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_DELAY_PIXELS, val);

} /* hsync_delay_changed() */



/*
 * vsync_delay_changed() - UI Callback function for when the user changes
 * the vsync delay.
 */

static void vsync_delay_changed(GtkSpinButton *spinbutton, gpointer user_data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(user_data);
    CtrlTarget *ctrl_target = ctk_gvo_sync->ctrl_target;
    gint val;

    val = gtk_spin_button_get_value(spinbutton);

    NvCtrlSetAttribute(ctrl_target, NV_CTRL_GVO_SYNC_DELAY_LINES, val);

} /* vsync_delay_changed() */




/**** NV-CONTROL/Misc Event Handlers *****************************************/

/*
 * gvo_sync_event_received() - Callback function for handling
 * NV-CONTROL events.
 */

static void gvo_sync_event_received(GObject *object,
                                    CtrlEvent *event,
                                    gpointer user_data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(user_data);
    GtkWidget *widget;    
    gint value;
    gboolean update_sync_format = FALSE;

    if (event->type != CTRL_EVENT_TYPE_INTEGER_ATTRIBUTE) {
        return;
    }

    value = event->int_attr.value;

    switch (event->int_attr.attribute) {
    case NV_CTRL_GVO_SYNC_MODE:
        ctk_gvo_sync->sync_mode = value;
        widget = ctk_gvo_sync->sync_mode_menu;
        
        g_signal_handlers_block_by_func(G_OBJECT(widget),
                                        G_CALLBACK(sync_mode_changed),
                                        (gpointer) ctk_gvo_sync);

        ctk_drop_down_menu_set_current_value
            (CTK_DROP_DOWN_MENU(widget), value);
        
        g_signal_handlers_unblock_by_func(G_OBJECT(widget),
                                          G_CALLBACK(sync_mode_changed),
                                          (gpointer) ctk_gvo_sync);
            
        post_sync_mode_menu_changed(ctk_gvo_sync, value);
        break;

    case NV_CTRL_GVO_SYNC_SOURCE:
        ctk_gvo_sync->sync_source = value;
        update_sync_format = TRUE;
        break;

    case NV_CTRL_GVO_COMPOSITE_SYNC_INPUT_DETECT_MODE:
        ctk_gvo_sync->comp_mode = value;
        update_sync_format = TRUE;
        break;

    case NV_CTRL_GVO_SYNC_DELAY_PIXELS:
        widget = ctk_gvo_sync->hsync_delay_spin_button;

        if (widget) {
            g_signal_handlers_block_by_func(G_OBJECT(widget),
                                            G_CALLBACK(hsync_delay_changed),
                                            (gpointer) ctk_gvo_sync);
        
            gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), value);
        
            g_signal_handlers_unblock_by_func(G_OBJECT(widget),
                                              G_CALLBACK(hsync_delay_changed),
                                              (gpointer) ctk_gvo_sync);
        }
        break;
        
    case NV_CTRL_GVO_SYNC_DELAY_LINES:
        widget = ctk_gvo_sync->vsync_delay_spin_button;
        
        if (widget) {
            g_signal_handlers_block_by_func(G_OBJECT(widget),
                                            G_CALLBACK(vsync_delay_changed),
                                            (gpointer) ctk_gvo_sync);
        
            gtk_spin_button_set_value(GTK_SPIN_BUTTON(widget), value);
            
            g_signal_handlers_unblock_by_func(G_OBJECT(widget),
                                              G_CALLBACK(vsync_delay_changed),
                                              (gpointer) ctk_gvo_sync);
        }
        break;

    case NV_CTRL_GVO_COMPOSITE_TERMINATION:
        widget = ctk_gvo_sync->composite_termination_button;

        if (widget) {
            g_signal_handlers_block_by_func
                (G_OBJECT(widget),
                 G_CALLBACK(composite_termination_toggled),
                 ctk_gvo_sync);
            
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), value);
            
            g_signal_handlers_unblock_by_func
                (G_OBJECT(widget),
                 G_CALLBACK(composite_termination_toggled),
                 ctk_gvo_sync);

            post_composite_termination_toggled(ctk_gvo_sync, value);
        }
        break;
    }


    /* Update the sync format menu */
    if (update_sync_format) {
        widget = ctk_gvo_sync->sync_format_menu;
        
        g_signal_handlers_block_by_func(G_OBJECT(widget),
                                        G_CALLBACK(sync_format_changed),
                                        (gpointer) ctk_gvo_sync);

        set_sync_format_menu(ctk_gvo_sync);
        
        g_signal_handlers_unblock_by_func(G_OBJECT(widget),
                                          G_CALLBACK(sync_format_changed),
                                          (gpointer) ctk_gvo_sync);

        post_sync_format_menu_changed(ctk_gvo_sync);
    }

} /* gvo_sync_event_received() */



/*
 * gvo_sync_probe_callback() - Callback function for when the
 * sync signals are probed.
 */

static gint gvo_sync_probe_callback(gpointer data)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(data);
    CtkGvo *ctk_gvo = ctk_gvo_sync->gvo_parent;

    /* update our copies of some SDI state variables */

    ctk_gvo_sync->input_video_format =
        CTK_GVO_BANNER(ctk_gvo->banner)->input_video_format;
    
    ctk_gvo_sync->comp_sync_input_detected =
        CTK_GVO_BANNER(ctk_gvo->banner)->composite_sync_input_detected;

    ctk_gvo_sync->sdi_sync_input_detected =
        CTK_GVO_BANNER(ctk_gvo->banner)->sdi_sync_input_detected;

    ctk_gvo_sync->sync_lock_status =
        CTK_GVO_BANNER(ctk_gvo->banner)->sync_lock_status;

    /* update the UI */
    
    update_input_video_format_text_entry(ctk_gvo_sync);

    update_sync_lock_status_text(ctk_gvo_sync);

    update_gvo_sync_sensitivity(ctk_gvo_sync);

    return TRUE;
    
} /* gvo_sync_probe_callback() */



/*
 * ctk_gvo_sync_select() - Callback function for when the GVO
 * sync config page is selected.
 */
void ctk_gvo_sync_select(GtkWidget *widget)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(widget);
    CtkGvo *ctk_gvo = ctk_gvo_sync->gvo_parent;

    /* Grab the GVO banner */

    ctk_gvo_banner_set_parent(CTK_GVO_BANNER(ctk_gvo->banner),
                              ctk_gvo_sync->banner_box,
                              gvo_sync_probe_callback, ctk_gvo_sync);
}



/*
 * ctk_gvo_sync_unselect() - Callback function for when the GVO
 * sync config page is unselected.
 */

void ctk_gvo_sync_unselect(GtkWidget *widget)
{
    CtkGvoSync *ctk_gvo_sync = CTK_GVO_SYNC(widget);
    CtkGvo *ctk_gvo = ctk_gvo_sync->gvo_parent;

    /* Release the GVO banner */

    ctk_gvo_banner_set_parent(CTK_GVO_BANNER(ctk_gvo->banner),
                              NULL, NULL, NULL);
}



/*
 * ctk_gvo_sync_create_help() - GVO sync configuration help page
 * creation.
 */

GtkTextBuffer* ctk_gvo_sync_create_help(GtkTextTagTable *table,
                                        CtkGvoSync *ctk_gvo_sync)
{
    GtkTextIter i;
    GtkTextBuffer *b;

    b = gtk_text_buffer_new(table);
    
    gtk_text_buffer_get_iter_at_offset(b, &i, 0);

    ctk_help_title(b, &i, _("GVO (Graphics to Video Out) Synchronization "
                   "options"));
    ctk_help_para(b, &i, _("This page gives access to configuration of the "
                  "SDI synchronization options."));

    ctk_help_heading(b, &i, _("Input Video Format"));
    ctk_help_para(b, &i, "%s", _(__input_video_format_help));
    ctk_help_heading(b, &i, _("Input Video Format Detect"));
    ctk_help_para(b, &i, "%s", _(__input_video_format_detect_help));
    ctk_help_heading(b, &i, _("Composite Termination"));
    ctk_help_para(b, &i, _("%s.  This allows the composite signal to be daisy "
                  "chained from a server load."),
                  _(__composite_termination_help));
    ctk_help_heading(b, &i, _("Sync Mode"));
    ctk_help_para(b, &i, "%s", _(__sync_mode_help));
    ctk_help_heading(b, &i, _("Sync Format"));
    ctk_help_para(b, &i, "%s", _(__sync_format_help));
    ctk_help_heading(b, &i, _("Sync Status"));
    ctk_help_para(b, &i, "%s", _(__sync_status_help));

    if ( ctk_gvo_sync->caps & NV_CTRL_GVO_CAPABILITIES_ADVANCE_SYNC_SKEW ) {
        ctk_help_heading(b, &i, _("HSync Advance"));
        ctk_help_para(b, &i, "%s", _(__hsync_advance_help));
        ctk_help_heading(b, &i, _("VSync Advance"));
        ctk_help_para(b, &i, "%s", _(__vsync_advance_help));
    } else {
        ctk_help_heading(b, &i, _("HSync Delay"));
        ctk_help_para(b, &i, "%s", _(__hsync_delay_help));
        ctk_help_heading(b, &i, _("VSync Delay"));
        ctk_help_para(b, &i, "%s", _(__vsync_delay_help));
    }

    ctk_help_finish(b);

    return b;
}
